const fs = require("fs");
const path = require("path");
const _ = require('../../util/utils.js');

const OBJECTS = {
  EMPTY: ' ',
  OPEN: '.',
  WALL: '#'
}

const DIRECTION = {
  RIGHT: 0,
  DOWN: 1,
  LEFT: 2,
  UP: 3
};

const DIRECTION_PAIR = {
  0: [1, 0],
  1: [0, 1],
  2: [-1, 0],
  3: [0, -1]
};

// convert the input with spaces into a 2D grid
function parseMap(inputs) {
  let map = inputs[0].split(/\r?\n/).map(row => row.split(''));
  let maxX = _.max(map.map(row => row.length));

  let grid = _.arr2D(maxX, map.length, OBJECTS.EMPTY);
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      grid[y][x] = map[y][x] || OBJECTS.EMPTY;
    }
  }

  return grid;
}

function partOne(inputs, testMode) {
  let map = parseMap(inputs);
  let instrs = inputs[1];

  let x = map[0].indexOf(OBJECTS.OPEN), y = 0, dir = DIRECTION.RIGHT;

  while (true) {
    if (instrs.length === 0) {
      return (1000 * (y + 1)) + (4 * (x + 1)) + dir;
    }

    if (instrs.startsWith("R")) {
      dir = (dir + 1) % 4;
      instrs = instrs.substring(1);
    } else if (instrs.startsWith("L")) {
      dir = (dir + 3) % 4;
      instrs = instrs.substring(1);
    } else {
      let [match, len, rest] = instrs.match(/(\d+)(.*)/);
      instrs = rest;
      len = Number(len);

      let [dirX, dirY] = DIRECTION_PAIR[dir];
      for (let i = 1; i <= len; i++) {
        let nextObj = _.safeGet2D(map, x + dirX, y + dirY, OBJECTS.EMPTY);

        if (nextObj === OBJECTS.WALL) break;
        if (nextObj === OBJECTS.OPEN) { x += dirX; y += dirY; }

        // perform wrapping
        if (nextObj === OBJECTS.EMPTY) {
          if (dir === DIRECTION.RIGHT) {
            let wrappedSpot = map[y].find(v => v !== OBJECTS.EMPTY);
            if (wrappedSpot === OBJECTS.WALL) break;
            x = map[y].findIndex(v => v !== OBJECTS.EMPTY);
            continue;
          }

          if (dir === DIRECTION.LEFT) {
            let wrappedSpot = map[y].slice().reverse().find(v => v !== OBJECTS.EMPTY);
            if (wrappedSpot === OBJECTS.WALL) break;
            x = map[y].length - 1 - map[y].slice().reverse().findIndex(v => v !== OBJECTS.EMPTY);
            continue;
          }

          if (dir === DIRECTION.DOWN) {
            let wrappedSpot = map.find(row => row[x] !== OBJECTS.EMPTY)[x];
            if (wrappedSpot === OBJECTS.WALL) break;
            y = map.findIndex(row => row[x] !== OBJECTS.EMPTY);
            continue;
          }

          if (dir === DIRECTION.UP) {
            let wrappedSpot = map.slice().reverse().find(row => row[x] !== OBJECTS.EMPTY)[x];
            if (wrappedSpot === OBJECTS.WALL || wrappedSpot === undefined) break;
            y = map.length - 1 - map.slice().reverse().findIndex(row => row[x] !== OBJECTS.EMPTY);
            continue;
          }
        }
      }
    }
  }
}

// generated by staring at a physical cube and following the edges (:
function crossBorder(faces, face, x, y, dir) {
  if (face === 'A') {
    if (dir === DIRECTION.RIGHT) {
      return ['B', 0, y, DIRECTION.RIGHT];
    } else if (dir === DIRECTION.DOWN) {
      return ['C', x, 0, DIRECTION.DOWN];
    } else if (dir === DIRECTION.LEFT) {
      return ['D', 0, 49 - y, DIRECTION.RIGHT];
    } else if (dir === DIRECTION.UP) {
      return ['F', 0, x, DIRECTION.RIGHT];
    }
  }
  
  if (face === 'B') {
    if (dir === DIRECTION.RIGHT) {
      return ['E', 49, 49 - y, DIRECTION.LEFT];
    } else if (dir === DIRECTION.DOWN) {
      return ['C', 49, x, DIRECTION.LEFT];
    } else if (dir === DIRECTION.LEFT) {
      return ['A', 49, y, DIRECTION.LEFT];
    } else if (dir === DIRECTION.UP) {
      return ['F', x, 49, DIRECTION.UP];
    }
  }
  
  if (face === 'C') {
    if (dir === DIRECTION.RIGHT) {
      return ['B', y, 49, DIRECTION.UP];
    } else if (dir === DIRECTION.DOWN) {
      return ['E', x, 0, DIRECTION.DOWN];
    } else if (dir === DIRECTION.LEFT) {
      return ['D', y, 0, DIRECTION.DOWN];
    } else if (dir === DIRECTION.UP) {
      return ['A', x, 49, DIRECTION.UP];
    }
  }

  if (face === 'D') {
    if (dir === DIRECTION.RIGHT) {
      return ['E', 0, y, DIRECTION.RIGHT];
    } else if (dir === DIRECTION.DOWN) {
      return ['F', x, 0, DIRECTION.DOWN];
    } else if (dir === DIRECTION.LEFT) {
      return ['A', 0, 49 - y, DIRECTION.RIGHT];
    } else if (dir === DIRECTION.UP) {
      return ['C', 0, x, DIRECTION.RIGHT];
    }
  }

  if (face === 'E') {
    if (dir === DIRECTION.RIGHT) {
      return ['B', 49, 49 - y, DIRECTION.LEFT];
    } else if (dir === DIRECTION.DOWN) {
      return ['F', 49, x, DIRECTION.LEFT];
    } else if (dir === DIRECTION.LEFT) {
      return ['D', 49, y, DIRECTION.LEFT];
    } else if (dir === DIRECTION.UP) {
      return ['C', x, 49, DIRECTION.UP];
    }
  }

  if (face === 'F') {
    if (dir === DIRECTION.RIGHT) {
      return ['E', y, 49, DIRECTION.UP];
    } else if (dir === DIRECTION.DOWN) {
      return ['B', x, 0, DIRECTION.DOWN];
    } else if (dir === DIRECTION.LEFT) {
      return ['A', y, 0, DIRECTION.DOWN];
    } else if (dir === DIRECTION.UP) {
      return ['D', x, 49, DIRECTION.UP];
    }
  }
}

// convert an individual face into where it would be on the original map
function addMapOffset(currentFace, x, y, testMode) {
  if (currentFace === 'A') {
    return [x + 50, y];
  } else if (currentFace === 'B') {
    return [x + 100, y];
  } else if (currentFace === 'C') {
    return [x + 50, y + 50];
  } else if (currentFace === 'D') {
    return [x, y + 100];
  } else if (currentFace === 'E') {
    return [x + 50, y + 100];
  } else if (currentFace === 'F') {
    return [x, y + 150];
  }
}

function partTwo(inputs, testMode) {
  let map = parseMap(inputs);
  let instrs = inputs[1];

  // specific to my input of:
  // .AB
  // .C.
  // DE.
  // F..
  let faceA = map.slice(0, 50).map(row => row.slice(50, 100));
  let faceB = map.slice(0, 50).map(row => row.slice(100, 150));
  let faceC = map.slice(50, 100).map(row => row.slice(50, 100));
  let faceD = map.slice(100, 150).map(row => row.slice(0, 50));
  let faceE = map.slice(100, 150).map(row => row.slice(50, 100));
  let faceF = map.slice(150, 200).map(row => row.slice(0, 50));

  let faces = {
    'A': faceA,
    'B': faceB,
    'C': faceC,
    'D': faceD,
    'E': faceE,
    'F': faceF
  };

  let x = 0, y = 0, dir = DIRECTION.RIGHT, currentFace = 'A', currentMap = faces[currentFace];

  while (true) {
    if (instrs.length === 0) {
      [x, y] = addMapOffset(currentFace, x, y, testMode);

      return (1000 * (y + 1)) + (4 * (x + 1)) + dir;
    }

    if (instrs.startsWith("R")) {
      dir = (dir + 1) % 4;
      instrs = instrs.substring(1);
    } else if (instrs.startsWith("L")) {
      dir = (dir + 3) % 4;
      instrs = instrs.substring(1);
    } else {
      let [match, len, rest] = instrs.match(/(\d+)(.*)/);
      instrs = rest;
      len = Number(len);

      for (let i = 1; i <= len; i++) {
        let [dirX, dirY] = DIRECTION_PAIR[dir];
        let nextObj = _.safeGet2D(currentMap, x + dirX, y + dirY, OBJECTS.EMPTY);

        // perform wrapping
        if (nextObj === OBJECTS.EMPTY) {
          let [newFace, newX, newY, newDir] = crossBorder(faces, currentFace, x, y, dir);

          if (faces[newFace][newY][newX] === OBJECTS.WALL) break;

          currentMap = faces[newFace];
          currentFace = newFace;
          x = newX;
          y = newY;
          dir = newDir;
        }

        if (nextObj === OBJECTS.WALL) break;
        if (nextObj === OBJECTS.OPEN) { x += dirX; y += dirY; }
      }
    }
  }
}

function main(file, testMode) {
  let inputs = fs.readFileSync(path.resolve(__dirname, file)).toString().split(/\r?\n\r?\n/);

  let partOneStart = performance.now();
  console.log(`Part one answer: ${partOne(inputs, testMode)} (took ${(performance.now() - partOneStart).toFixed(0)}ms)`);

  let partTwoStart = performance.now()
  console.log(`Part two answer: ${partTwo(inputs, testMode)} (took ${(performance.now() - partTwoStart).toFixed(0)}ms)`);
}

module.exports = { main };